# Android事件传递机制
对于Android新手来说，事件传递机制是第一个复杂知识点。我们现在来一步一步理顺。
首先我们的View可以分为两类ViewGroup， View。对于ViewGroup，涉及处理事件的方法以有：
dispatchTouchEvent
onInterceptTouchEvent
onTouchEvent

而对于View则只涉及到
dispatchTouchEvent
onTouchEvent

事件的传递是我们触摸屏幕时， 先传递给Activity。我们的Activity传递给DecorView，这个最大的ViewGroup。一层一层这样往里传递下去。在每一次都会根据如下顺序：
![图片来自https://github.com/GcsSloop/AndroidNote/blob/master/CustomView/Advance/%5B12%5DDispatch-TouchEvent-Theory.md](https://camo.githubusercontent.com/f2769428c03404a2e0b1eb97d7701a619d54fd51/687474703a2f2f7777322e73696e61696d672e636e2f6c617267652f30303558746469326a773166383869307138756f7a6a33306e6d306b7177686d2e6a7067)

## 常用到的各个方法的解释
dispatchTouchEvent方法是最终决定该View如何处理该Touch事件的。因为onInterceptTouchEvent和onTouchEvent都是在该方法里调用的。因此我们直接重写该方法，可以实现自定义的Touch事件处理。

onIntereptTouchEvent
该方法用来决定是否拦截，由自己处理不往下传递了。

onTouchEvent
自己处理该Touch事件。

requestDisallowInterceptTouchEvent
此方法来重写设置是否拦截事件。常常在内部拦截法中使用。
## 一个完整的Touch事件
一个完整的事件一定是以ACTIONt_DOWN开始-->0或多个ACTION_MOVE-->ACTION_UP结束的。

还有ACTION_CANCEL，此事件是系统发送，当之前的事件是由子View处理，然后后续事件又被上层拦截了，则系统会发送一个CANCEL事件通知子View，你别等了，事件我消费了。

ACTION_OUTER此事件特别少用点。当我们点击PopupView时，点击空白区域，会触发该事件。

## 常见的解决事件冲突
### 外部拦街法
由parent来通过事件的一些判断条件决定是否自己处理还是传递下去。

### 内部拦截法
由子view的onTouchEvent方法中根据判断条件来决定是消费还是不消费回传给上一层。或者是通过调用disallowInterceptTouchEvent来动态的改变父类的对事件的拦截能力。
此方法的套路一般是parent中的onTouchEvent方法的ACTION_DOWN永远返回true。其他MOVE和UP都返回false。子View的onTouchEvent方法的ACTION_DOWN也返回false，

## GuestureDetector
系统为我们设计的一个手势检测类